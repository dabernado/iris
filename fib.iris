main:   start               ( compute Nth fibonacci number )

        add @2 1            ( @1=0, @2=1, base case )
        add @3 5            ( hold N, loop counter )
        neg @3              ( shorthand for "xori @3 0x1ff; addi @3 1" )
        add @3 1            ( setup @3 for loop count )
call:   beq @0 @8 t1        ( call fib routine; br = 5 )

rexit:  beq @0 @8 t1

top:    blt @0 @3 -bottom
t1:     beq @0 @8 -rexit
        add @8 1
        add @1 @2
        xor @1 @2           ( swap @1, @2)
        xor @2 @1
        xor @1 @2
        add @3 1            ( increment counter )
b1:     beq @0 @3 exit      ( exit condition )
bottom: blt @0 @3 top       ( loop until done )

exit:   beq @0 @3 -b1       ( exit point. top and bottom could
                              have an unconditional jump )

( Copy output and call the fib generator in reverse )
        exch [@4,0,0] @2    ( result to address in @7, index and offset = 0 )
rcall:  beq @0 @8 -b1       ( call backwards; goto b1 )

( reclaim other space 
  we know @0=0, @1=5, @2=8, @3=0, @7=fib(5), @8=0
  clear out those values )
        sub @2 1
        add @3 4

end: finish
