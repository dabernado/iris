// Primitive Types
0	:= empty type
1	:= unit type
nat	:= unsigned integer

// Functions
ID <-> ID		: ?a <-> ?a
/*
 * Identity; does nothing
 */

ZEROI <-> ZEROE		: ?a <-> (0 + ?a)
/*
 * Introduce/eliminate sum variant of type 0
 */

SWAPS <-> SWAPS		: (?a + ?b) <-> (?b + ?a)
/*
 * Swap the two variant types' sides
 * d = division value of sum type
 */

ASSRS <-> ASSLS		: ((?a + ?b) + ?c) <-> (?a + (?b + ?c))
/*
 * Associate inner sum with types on the right or left
 */

UNITI <-> UNITE		: ?a <-> (1 * ?a)
/*
 * Introduce/eliminate product with unit type
 */

SWAPP <-> SWAPP 	: (?a * ?b) <-> (?b * ?a)
/*
 * Swap the first and second values
 */

ASSRP <-> ASSLP		: ((?a * ?b) * ?c) <-> (?a * (?b * ?c))
/*
 * Associate inner product with types on the right or left
 */

DIST <-> FACT		: ((?a + ?b) * ?c) <-> ((?a * ?c) + (?b * ?c))
/*
 * Distribute inner sum over both product values/Factor inner
 * sum into first value
 *
 * d = first variant value of the right hand of the type, or 0
 * if there are only two types
 */

EXPN <-> COLN		: 0 <-> (-?a + ?a)
/*
 * Reverse type sign and direction of execution
 *
 * d = first variant value of the right hand of the type, or 0
 * if there are only two types
 */

EXPF i <-> COLF i	: 1 <-> (1/?a * ?a)
/*
 * Allocate/deallocate new variable
 * i = index of fraction array to value being introduced
 */

// Arithmetic
ADD <-> SUB		: (nat * nat) <-> (nat * nat)
/*
 * Add/subtract two integers, with result placed in first value
 */

ADDI n <-> SUBI n	: nat <-> nat 
/*
 * Add/subtract constant to/from integer
 */

XOR <-> XOR		: (nat * nat) <-> (nat * nat)
/*
 * Exclusive-or on two integers, result placed in first value
 */

XORI n <-> XORI n 	: nat <-> nat
/*
 * Exclusive-or integer with constant
 */

CSWAP <-> CSWAP		: ((nat * nat) * nat) <-> ((nat * nat) * nat)
/*
 * Controlled swap on two integers, with second value as control
 */

CSWAPI n <-> CSWAPI n	: (nat * nat) <-> (nat * nat)
/*
 * Controlled swap on two integers, with constant as control
 */

RR <-> RL		: (nat * nat) <-> (nat * nat)
/*
 * Rotate bits of an integer left/right
 */

RRI n <-> RLI n		: nat <-> nat
/*
 * Rotate bits of an integer left/right by constant value
 */

LTI <-> LTE		: (nat * nat) <-> ((nat * nat) + (nat * nat))
/*
 * Create left/right value from nat product if first value is
 * less than second value, or collapse back into nat product
 * if sum tag and nat comparison match
 */

LTII n <-> LTEI n	: nat <-> (nat + nat)
/*
 * Create left/right value from nat if value is less than
 * immediate value, or collapse back into nat if sum tag
 * and nat comparison match
 */

// Combinators
+{
/*
 * Left hand sum combinator delimiter
 * l = number of instructions in left hand of combinator
 * r = number of instructions in right hand of combinator
 * d = division value of sum type
 */

-- // Division point of combinator

}+
/*
 * Right hand sum combinator delimiter
 * l = number of instructions in left hand of combinator
 * r = number of instructions in right hand of combinator
 * d = division value of sum type
 */

*{
/*
 * First product combinator delimiter
 * j = jump to first instruction of second half of combinator
 */

-- // Division point of combinator

}*
/*
 * Second product combinator delimiter
 * j = jump to last instruction of first half of combinator
 */

// Control/Memory
CALL f <-> UNCALL f		: ?a <-> ?b
/*
 * Invoke function forwards/backwards on datatype
 * f = index in function list to invoked function
 */

SYSC f <-> RSYSC f		: ?a <-> ?b
/*
 * Invoke system call forwards/backwards on datatype; used for
 * ISA extensions and I/O ops
 * f = id of system function
 */

START <-> END			: ?a <-> ?a
/*
 * Designates beginning/end of function; operationally equivalent to ID
 */

// Example Code
data0: (int * int) + (int * bool)	-- type definition
data1: (int + bool) * int

function: data0 <-> data1		-- function definition
    START
    +{
        ADD
        ID
	--
        SWAPP
    }+
    FACT
    *{			// fst = @r0, snd = @r1
        +{
	    NEG
	    --
	    MULI 2
	}+
	--
	ADDI 69
    }*
    END

// Instruction Encoding
/*
 * I-Type
 *
 * 31				6 5	   0
 * [	        imm		] [ opcode ]
 *	        26b		      6b
 *
 * Instructions that do not contain additional information or
 * contain a constant value are represented by the I-Type
 * encoding. Most IRIS instructions are I-Type encoded.
 */

/*
 * S-Type
 *
 * 31 30 29	 22 21     14 13      6 5	 0
 * [ 0 ] [   rc   ] [  lc   ] [  div  ] [ opcode ]
 *  2b       8b	       8b	 8b	    6b
 *
 * The only instructions with the S-Type encoding are SUMS/SUME,
 * which contain the division value for a
 * given sum type, and the number of instructions in the left
 * and right hand side of the combinator. The last two bits
 * are kept empty.
 */
